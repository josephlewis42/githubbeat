
// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates contributors.go. It can be invoked by running
// go generate
package main

import (
	"log"
	"os"
	"text/template"
	"time"
)

func main() {

	f, err := os.Create("listers.go")
	die(err)
	defer f.Close()

	clientListTemplate.Execute(f, struct {
		Timestamp time.Time
		PageableLists     []repositoryClientListItem
	}{
		Timestamp: time.Now(),
		PageableLists:   []repositoryClientListItem{
			{"ListBranches", "ListOptions", "Branch"},	
			{"ListForks", "RepositoryListForksOptions", "Repository"},
			{"ListComments", "ListOptions", "RepositoryComment"},
			{"ListCommits", "CommitsListOptions", "RepositoryCommit"},
			{"ListContributors", "ListContributorsOptions", "Contributor"},
			{"ListDeployments", "DeploymentsListOptions", "Deployment"},
			{"ListHooks", "ListOptions", "Hook"},
			{"ListInvitations", "ListOptions", "RepositoryInvitation"},
			{"ListKeys", "ListOptions", "Key"},
			{"ListPagesBuilds", "ListOptions", "PagesBuild"},
			{"ListProjects", "ProjectListOptions", "Project"},
			{"ListReleases", "ListOptions", "RepositoryRelease"},
			{"ListTags", "ListOptions", "RepositoryTag"},
			{"ListTeams", "ListOptions", "Team"},
			{"ListCollaborators", "ListCollaboratorsOptions", "User"},
		},
	})
}

//func (s *RepositoriesService) ListByOrg(ctx context.Context, org string, opt *RepositoryListByOrgOptions) ([]*Repository, *Response, error)

/**
func (s *RepositoriesService) ListAllTopics(ctx context.Context, owner, repo string) ([]string, *Response, error)
func (s *RepositoriesService) ListCodeFrequency(ctx context.Context, owner, repo string) ([]*WeeklyStats, *Response, error)
func (s *RepositoriesService) ListCommitActivity(ctx context.Context, owner, repo string) ([]*WeeklyCommitActivity, *Response, error)
 error)
func (s *RepositoriesService) ListContributorsStats(ctx context.Context, owner, repo string) ([]*ContributorStats, *Response, error)
func (s *RepositoriesService) ListLanguages(ctx context.Context, owner string, repo string) (map[string]int, *Response, error)
func (s *RepositoriesService) ListParticipation(ctx context.Context, owner, repo string) (*RepositoryParticipation, *Response, error)
func (s *RepositoriesService) ListPunchCard(ctx context.Context, owner, repo string) ([]*PunchCard, *Response, error)
func (s *RepositoriesService) ListReleaseAssets(ctx context.Context, owner, repo string, id int64, opt *ListOptions) ([]*ReleaseAsset, *Response, error)
func (s *RepositoriesService) ListTrafficPaths(ctx context.Context, owner, repo string) ([]*TrafficPath, *Response, error)
func (s *RepositoriesService) ListTrafficReferrers(ctx context.Context, owner, repo string) ([]*TrafficReferrer, *Response, error)



func (s *RepositoriesService) ListStatuses(ctx context.Context, owner, repo, ref string, opt *ListOptions) ([]*RepoStatus, *Response, error)
func (s *RepositoriesService) ListTrafficViews(ctx context.Context, owner, repo string, opt *TrafficBreakdownOptions) (*TrafficViews, *Response, error)
func (s *RepositoriesService) ListRequiredStatusChecksContexts(ctx context.Context, owner, repo, branch string) (contexts []string, resp *Response, err error)
func (s *RepositoriesService) ListCommitComments(ctx context.Context, owner, repo, sha string, opt *ListOptions) ([]*RepositoryComment, *Response,
func (s *RepositoriesService) ListDeploymentStatuses(ctx context.Context, owner, repo string, deployment int64, opt *ListOptions) ([]*DeploymentStatus, *Response, error)
**/

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}


type repositoryClientListItem struct {
	Function 	string
	OptionType 	string
	ResultType 	string
}

var clientListTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

package beater

import (
    "github.com/google/go-github/github"
)


{{- range .PageableLists}}

func (rc *repositoryClient) {{.Function}}(max int) ([]*github.{{.ResultType}}, error) {
	opt := &github.{{.OptionType}}{}

	var results []*github.{{.ResultType}}

	for {
		list, resp, err := rc.client.Repositories.{{.Function}}(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

{{- end }}
`))
