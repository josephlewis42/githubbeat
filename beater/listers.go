// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// 2018-04-06 05:59:50.310028445 -0700 PDT m=+0.000689466

package beater

import (
    "github.com/google/go-github/github"
)

func (rc *repositoryClient) ListBranches(max int) ([]*github.Branch, error) {
	opt := &github.ListOptions{}

	var results []*github.Branch

	for {
		list, resp, err := rc.client.Repositories.ListBranches(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListForks(max int) ([]*github.Repository, error) {
	opt := &github.RepositoryListForksOptions{}

	var results []*github.Repository

	for {
		list, resp, err := rc.client.Repositories.ListForks(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListComments(max int) ([]*github.RepositoryComment, error) {
	opt := &github.ListOptions{}

	var results []*github.RepositoryComment

	for {
		list, resp, err := rc.client.Repositories.ListComments(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListCommits(max int) ([]*github.RepositoryCommit, error) {
	opt := &github.CommitsListOptions{}

	var results []*github.RepositoryCommit

	for {
		list, resp, err := rc.client.Repositories.ListCommits(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListContributors(max int) ([]*github.Contributor, error) {
	opt := &github.ListContributorsOptions{}

	var results []*github.Contributor

	for {
		list, resp, err := rc.client.Repositories.ListContributors(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListDeployments(max int) ([]*github.Deployment, error) {
	opt := &github.DeploymentsListOptions{}

	var results []*github.Deployment

	for {
		list, resp, err := rc.client.Repositories.ListDeployments(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListHooks(max int) ([]*github.Hook, error) {
	opt := &github.ListOptions{}

	var results []*github.Hook

	for {
		list, resp, err := rc.client.Repositories.ListHooks(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListInvitations(max int) ([]*github.RepositoryInvitation, error) {
	opt := &github.ListOptions{}

	var results []*github.RepositoryInvitation

	for {
		list, resp, err := rc.client.Repositories.ListInvitations(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListKeys(max int) ([]*github.Key, error) {
	opt := &github.ListOptions{}

	var results []*github.Key

	for {
		list, resp, err := rc.client.Repositories.ListKeys(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListPagesBuilds(max int) ([]*github.PagesBuild, error) {
	opt := &github.ListOptions{}

	var results []*github.PagesBuild

	for {
		list, resp, err := rc.client.Repositories.ListPagesBuilds(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListProjects(max int) ([]*github.Project, error) {
	opt := &github.ProjectListOptions{}

	var results []*github.Project

	for {
		list, resp, err := rc.client.Repositories.ListProjects(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListReleases(max int) ([]*github.RepositoryRelease, error) {
	opt := &github.ListOptions{}

	var results []*github.RepositoryRelease

	for {
		list, resp, err := rc.client.Repositories.ListReleases(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListTags(max int) ([]*github.RepositoryTag, error) {
	opt := &github.ListOptions{}

	var results []*github.RepositoryTag

	for {
		list, resp, err := rc.client.Repositories.ListTags(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListTeams(max int) ([]*github.Team, error) {
	opt := &github.ListOptions{}

	var results []*github.Team

	for {
		list, resp, err := rc.client.Repositories.ListTeams(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}

func (rc *repositoryClient) ListCollaborators(max int) ([]*github.User, error) {
	opt := &github.ListCollaboratorsOptions{}

	var results []*github.User

	for {
		list, resp, err := rc.client.Repositories.ListCollaborators(rc.ctx, rc.GetOwner(), rc.GetName(), opt)
		if err != nil {
			return results, err
		}
		
		results = append(results, list...)
		if resp.NextPage == 0 || (len(results) >= max && max > 0) {
			break
		}
		
		opt.Page = resp.NextPage
	}

	return results, nil
}
